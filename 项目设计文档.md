# 智能天气生活助手系统 - 项目设计文档

## 1. 项目概述

### 1.1 项目名称
智能天气生活助手系统 (Intelligent Weather Life Assistant System)

### 1.2 项目目标
基于机器学习的智能天气预测与生活建议系统，为用户提供准确的天气预报和个性化的生活建议。

### 1.3 技术栈
- **后端**: Python FastAPI + TensorFlow + Scikit-learn
- **前端**: HTML5 + CSS3 + JavaScript + Chart.js
- **机器学习**: ARIMA + LSTM + Random Forest
- **部署**: Uvicorn ASGI服务器

---

## 2. 系统架构

```
┌─────────────────┐    HTTP/JSON    ┌─────────────────┐
│   前端界面      │ ←──────────────→ │   FastAPI后端   │
│  (HTML/CSS/JS)  │                 │                 │
└─────────────────┘                 └─────────────────┘
                                              │
                                              ▼
                                    ┌─────────────────┐
                                    │  机器学习模型   │
                                    │                 │
                                    │ ARIMA + LSTM    │
                                    │ + Random Forest │
                                    └─────────────────┘
                                              │
                                              ▼
                                    ┌─────────────────┐
                                    │   数据存储      │
                                    │  (CSV/JSON)    │
                                    └─────────────────┘
```

---

## 3. 核心模块功能实现详解

### 3.1 天气数据预测模块 (`app/forecasting.py`)

#### 功能描述
基于历史天气数据，使用ARIMA和LSTM模型预测未来7天的天气情况，包括温度、降水、湿度、风速等。

#### 技术实现

**1. ARIMA模型 (自回归积分移动平均模型)**
```python
# 模型原理：ARIMA(p,d,q)
# p: 自回归项数，d: 差分次数，q: 移动平均项数
from statsmodels.tsa.arima.model import ARIMA
from pmdarima import auto_arima

def train_arima_model(temperature_data):
    """
    训练ARIMA模型用于温度预测
    """
    # 自动确定最佳参数
    model = auto_arima(temperature_data, 
                       seasonal=False, 
                       stepwise=True,
                       suppress_warnings=True,
                       error_action='ignore')
    
    # 获取最佳参数
    best_order = model.order
    best_seasonal_order = model.seasonal_order
    
    # 使用最佳参数重新训练
    final_model = ARIMA(temperature_data, order=best_order)
    fitted_model = final_model.fit()
    
    return fitted_model, best_order
```

**模型应用场景**：
- 温度预测：利用时间序列的连续性和季节性
- 参数自动优化：通过AIC/BIC准则自动选择最佳p,d,q值
- 差分处理：处理非平稳时间序列数据

**2. LSTM神经网络模型**
```python
# 模型架构：长短期记忆网络
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.optimizers import Adam

def build_lstm_model(sequence_length, n_features):
    """
    构建LSTM模型用于多变量天气预测
    """
    model = Sequential([
        # 第一层LSTM，返回序列
        LSTM(64, return_sequences=True, 
             input_shape=(sequence_length, n_features)),
        Dropout(0.2),
        
        # 第二层LSTM
        LSTM(32, return_sequences=False),
        Dropout(0.2),
        
        # 输出层
        Dense(16, activation='relu'),
        Dense(n_features)  # 预测多个特征
    ])
    
    model.compile(optimizer=Adam(learning_rate=0.001),
                  loss='mse',
                  metrics=['mae'])
    
    return model

def prepare_lstm_data(data, sequence_length):
    """
    准备LSTM训练数据
    """
    X, y = [], []
    for i in range(len(data) - sequence_length):
        X.append(data[i:(i + sequence_length)])
        y.append(data[i + sequence_length])
    return np.array(X), np.array(y)
```

**模型应用场景**：
- 多变量预测：同时预测温度、降水、湿度、风速
- 序列建模：捕捉天气数据的时间依赖关系
- 非线性关系：学习复杂的天气模式

**3. 模型融合策略**
```python
def ensemble_forecast(arima_model, lstm_model, input_data):
    """
    融合ARIMA和LSTM的预测结果
    """
    # ARIMA预测
    arima_pred = arima_model.forecast(steps=7)
    
    # LSTM预测
    lstm_input = prepare_lstm_input(input_data)
    lstm_pred = lstm_model.predict(lstm_input)
    
    # 加权融合 (可调整权重)
    arima_weight = 0.6
    lstm_weight = 0.4
    
    ensemble_pred = (arima_weight * arima_pred + 
                     lstm_weight * lstm_pred)
    
    return ensemble_pred
```

### 3.2 极端天气预警模块 (`app/alerts.py`)

#### 功能描述
使用随机森林分类器识别极端天气风险，生成预警信息。

#### 技术实现

**1. 随机森林分类器**
```python
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler

def train_risk_classifier(weather_data):
    """
    训练极端天气风险分类器
    """
    # 特征工程
    features = ['temperature_c', 'precipitation_mm', 
                'wind_speed_ms', 'humidity']
    
    # 标签生成规则
    labels = (
        (weather_data['temperature_c'] < 0) |      # 极端低温
        (weather_data['temperature_c'] > 35) |     # 极端高温
        (weather_data['precipitation_mm'] > 10) |  # 强降水
        (weather_data['wind_speed_ms'] > 8)        # 大风
    ).astype(int)
    
    # 数据预处理
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(weather_data[features])
    
    # 训练随机森林
    rf_model = RandomForestClassifier(
        n_estimators=120,      # 树的数量
        max_depth=6,           # 最大深度
        random_state=42,       # 随机种子
        class_weight='balanced' # 处理类别不平衡
    )
    
    rf_model.fit(X_scaled, labels)
    
    return rf_model, scaler
```

**模型应用场景**：
- 风险分类：二分类（低风险/高风险）
- 特征重要性：分析哪些天气因素对风险影响最大
- 实时预警：对新数据进行快速风险评估

**2. 预警规则引擎**
```python
def generate_weather_alerts(forecast_data, rf_model, scaler):
    """
    生成天气预警信息
    """
    alerts = []
    
    for date, weather in forecast_data.items():
        # 特征提取
        features = np.array([
            weather.get('temperature_c', 20.0),
            weather.get('precipitation_mm', 0.0),
            weather.get('wind_speed_ms', 3.0),
            weather.get('humidity', 60.0)
        ]).reshape(1, -1)
        
        # 标准化
        features_scaled = scaler.transform(features)
        
        # 风险预测
        risk_level = rf_model.predict(features_scaled)[0]
        risk_prob = rf_model.predict_proba(features_scaled)[0]
        
        # 生成具体预警原因
        reasons = []
        if weather.get('temperature_c', 0) < -5:
            reasons.append("极端低温")
        if weather.get('temperature_c', 100) > 35:
            reasons.append("极端高温")
        if weather.get('precipitation_mm', 0) > 10:
            reasons.append("强降水")
        if weather.get('wind_speed_ms', 0) > 8:
            reasons.append("大风")
        
        alerts.append({
            "date": date,
            "level": "高风险" if risk_level == 1 else "低风险",
            "confidence": max(risk_prob),
            "reasons": reasons,
            "weather_data": weather
        })
    
    return alerts
```

### 3.3 自然语言处理模块 (`app/nlp.py`)

#### 功能描述
理解用户的自然语言查询，生成个性化的天气相关生活建议。

#### 技术实现

**1. 意图识别与实体提取**
```python
import re
from datetime import datetime, timedelta

def parse_user_query(query):
    """
    解析用户查询，提取意图和实体
    """
    query_lower = query.lower()
    
    # 意图识别
    intents = {
        'clothing': ['穿什么', '穿', '衣服', '着装'],
        'umbrella': ['伞', '雨伞', '带伞', '下雨'],
        'outdoor': ['出门', '外出', '活动', '运动'],
        'general': ['天气', '怎么样', '建议']
    }
    
    detected_intent = 'general'
    for intent, keywords in intents.items():
        if any(keyword in query_lower for keyword in keywords):
            detected_intent = intent
            break
    
    # 时间实体提取
    time_entities = {
        'today': ['今天', '现在', '今天'],
        'tomorrow': ['明天', '明天'],
        'day_after': ['后天', '后天'],
        'weekend': ['周末', '周六', '周日']
    }
    
    detected_time = 'today'
    for time_key, keywords in time_entities.items():
        if any(keyword in query_lower for keyword in keywords):
            detected_time = time_key
            break
    
    return {
        'intent': detected_intent,
        'time': detected_time,
        'original_query': query
    }
```

**2. 建议生成引擎**
```python
def generate_clothing_advice(weather_data, time_period):
    """
    基于天气数据生成穿衣建议
    """
    temp = weather_data.get('temperature_c', 20)
    precip = weather_data.get('precipitation_mm', 0)
    humidity = weather_data.get('humidity', 60)
    
    advice = []
    
    # 温度建议
    if temp < 10:
        advice.append("建议穿厚外套、毛衣、围巾等保暖衣物")
    elif temp < 20:
        advice.append("建议穿薄外套、长袖衬衫等春秋装")
    elif temp < 30:
        advice.append("建议穿短袖、薄裤等夏装")
    else:
        advice.append("建议穿轻薄透气的衣物，注意防晒")
    
    # 降水建议
    if precip > 5:
        advice.append("有降水，记得带伞或穿防水鞋")
    
    # 湿度建议
    if humidity > 80:
        advice.append("湿度较高，建议选择透气性好的衣物")
    
    return advice

def generate_umbrella_advice(weather_data):
    """
    生成带伞建议
    """
    precip = weather_data.get('precipitation_mm', 0)
    wind = weather_data.get('wind_speed_ms', 0)
    
    if precip > 10:
        return "强降水天气，强烈建议带伞"
    elif precip > 5:
        return "有降水，建议带伞"
    elif precip > 0:
        return "轻微降水，可选择性带伞"
    else:
        return "无降水，无需带伞"
```

### 3.4 数据加载与处理模块 (`app/data_loader.py`)

#### 功能描述
负责数据的加载、清洗、预处理和存储管理。

#### 技术实现

**1. 数据清洗与预处理**
```python
import pandas as pd
import numpy as np
from sklearn.impute import SimpleImputer

def clean_weather_data(df):
    """
    清洗天气数据
    """
    # 处理缺失值
    numeric_columns = ['temperature_c', 'precipitation_mm', 
                       'humidity', 'wind_speed_ms']
    
    # 使用中位数填充缺失值
    imputer = SimpleImputer(strategy='median')
    df[numeric_columns] = imputer.fit_transform(df[numeric_columns])
    
    # 异常值检测与处理
    for col in numeric_columns:
        Q1 = df[col].quantile(0.25)
        Q3 = df[col].quantile(0.75)
        IQR = Q3 - Q1
        
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        
        # 将异常值替换为边界值
        df[col] = df[col].clip(lower=lower_bound, upper=upper_bound)
    
    # 数据类型转换
    df['date'] = pd.to_datetime(df['date'])
    
    return df

def validate_weather_data(df):
    """
    验证天气数据的合理性
    """
    validation_rules = {
        'temperature_c': (-50, 60),      # 温度范围
        'precipitation_mm': (0, 1000),   # 降水量范围
        'humidity': (0, 100),            # 湿度范围
        'wind_speed_ms': (0, 50)         # 风速范围
    }
    
    validation_results = {}
    
    for column, (min_val, max_val) in validation_rules.items():
        if column in df.columns:
            invalid_count = len(df[(df[column] < min_val) | 
                                   (df[column] > max_val)])
            validation_results[column] = {
                'valid': invalid_count == 0,
                'invalid_count': invalid_count,
                'range': (min_val, max_val)
            }
    
    return validation_results
```

**2. 数据存储与缓存**
```python
import json
import pickle
from pathlib import Path

class WeatherDataManager:
    def __init__(self, data_dir="data"):
        self.data_dir = Path(data_dir)
        self.data_dir.mkdir(exist_ok=True)
        
        # 缓存文件路径
        self.cache_file = self.data_dir / "weather_cache.pkl"
        self.forecast_cache = self.data_dir / "forecast_cache.json"
    
    def save_forecast_cache(self, forecast_data):
        """
        保存预测结果到缓存
        """
        cache_data = {
            'timestamp': datetime.now().isoformat(),
            'data': forecast_data
        }
        
        with open(self.forecast_cache, 'w', encoding='utf-8') as f:
            json.dump(cache_data, f, ensure_ascii=False, indent=2)
    
    def load_forecast_cache(self, max_age_hours=1):
        """
        加载预测缓存，检查是否过期
        """
        if not self.forecast_cache.exists():
            return None
        
        try:
            with open(self.forecast_cache, 'r', encoding='utf-8') as f:
                cache_data = json.load(f)
            
            # 检查缓存是否过期
            cache_time = datetime.fromisoformat(cache_data['timestamp'])
            age = datetime.now() - cache_time
            
            if age.total_seconds() < max_age_hours * 3600:
                return cache_data['data']
            else:
                return None
                
        except Exception as e:
            print(f"加载缓存失败: {e}")
            return None
```

---

## 4. 前端技术实现

### 4.1 响应式设计
- **CSS Grid布局**：7天预报卡片使用网格布局
- **媒体查询**：适配不同屏幕尺寸
- **Flexbox**：灵活的组件布局

### 4.2 交互功能
- **卡片翻转**：点击显示数据来源
- **主题切换**：支持浅色/深色主题
- **语言切换**：中英文界面
- **实时搜索**：城市搜索与自动完成

### 4.3 数据可视化
- **Chart.js**：14天历史数据图表
- **SVG图标**：天气状态图标
- **动画效果**：加载动画、悬停效果

---

## 5. 部署与运维

### 5.1 环境配置
```bash
# 环境变量设置
export TF_CPP_MIN_LOG_LEVEL=2
export TF_ENABLE_ONEDNN_OPTS=0

# 依赖安装
pip install -r requirements.txt
```

### 5.2 启动脚本
- `start_server.bat`：Windows批处理脚本
- `start_server.ps1`：PowerShell脚本

### 5.3 性能优化
- **模型缓存**：避免重复训练
- **数据缓存**：减少重复计算
- **异步处理**：提高响应速度

---

## 6. 项目特色功能

### 6.1 智能建议系统
- 基于天气数据的个性化建议
- 自然语言查询理解
- 多维度生活建议

### 6.2 极端天气预警
- 机器学习风险识别
- 实时预警信息
- 多级风险分类

### 6.3 数据融合预测
- ARIMA + LSTM模型融合
- 多变量天气预测
- 预测结果置信度评估

---

## 7. 未来扩展方向

### 7.1 功能扩展
- 空气质量预测
- 交通出行建议
- 农业气象服务

### 7.2 技术升级
- 深度学习模型优化
- 实时数据接入
- 移动端应用开发

### 7.3 用户体验
- 语音交互
- 个性化设置
- 社交分享功能
